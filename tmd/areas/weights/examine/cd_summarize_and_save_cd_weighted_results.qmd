---
output: html_document
editor_options: 
 chunk_output_type: console
---

# Summarize and save data by Congressional District

** ONLY run the code below when tmd data have changed **

Get data and merge: 

-   area targets
-   tmd2021 data used when creating area weights (tmd2021_cache.csv)
-   weights
-   merge tmd2021 with weights

Summarize and save:

-   calculate weighted values for tmd2021 data using area weights
-   get sums by groups: area x data_source x agi range
-   supplement with sums across agi ranges - area x data source
-   and again with sums across data_source
-   calculate averages (sums / weighted ns)
-   stack files and save

## Setup

```{r}
#| label: setup
#| output: false

source(here::here("R", "libraries.R"))

source(here::here("R", "system_specific_constants.R"))
source(here::here("R", "constants.R"))

source(here::here("R", "functions.R"))

```

## Get data and merge

## Get tmd2021 file

Get `tmd2021_cache.csv`, a saved version of data from an object constructed during creation of area weights, in the file `create_taxcalc_cached_files.py`. `tmd2021_cache.csv` is the then-current tmd file with 2021 values, run through Tax-Calculator with 2021 law, written as csv. It includes all Tax-Calculator input and output variables.

The master branch of tax-microdata-benchmarking does not write `tmd2021_cache.csv` (it saves a few key variables in a cache), but it is written in Don Boyd's fork, branch xprep2, (see commit fe0c687433217ef455e359d3f2450c9e3e18cc06).

```{r}
#| label: get-tmd
#| output: false

TMDDIR <- here::here("..", "..", "..", "storage", "output")
fpath <-  fs::path(TMDDIR, "tmd2021_cache.csv")
tmd2021 <- vroom(fpath)
ns(tmd2021)
# tmd2021 |> filter(row_number() < 20) |> select(RECID, s006, c00100)

```

## Get previously saved area weights

```{r}
#| label: get-weights
#| output: false

cdweights <- readRDS(here::here("intermediate", "cdweights.rds"))

# fpath <- here::here("intermediate", "cdweights.rds")
# ns(file_info(fpath))
# file_info(fpath)$change_time # The time of last file status change - as a POSIXct datetime.
# file_info(fpath)$modification_time # The time of last data modification, as a POSIXct datetime.

```

## Supplement the weights file with selected tmd variables

```{r}
#| label: agibins
#| output: false

# 0 = Total
# 1 = Under $1
# 2 = $1 under $10,000
# 3 = $10,000 under $25,000
# 4 = $25,000 under $50,000
# 5 = $50,000 under $75,000
# 6 = $75,000 under $100,000
# 7 = $100,000 under $200,000
# 8 = $200,000 under $500,000
# 9 = $500,000 or more

# icuts <- c(-Inf, 1, 10e3, 25e3, 50e3, 75e3, 100e3, 200e3, 500e3, Inf)
icuts <- CDICUTS

```

## Bind selected Tax-Calculator variables to area weights data frame

```{r}
#| label: bind-taxcalc-variables
#| output: false

# see what variables are mapped
# vmap <- read_csv(fs::path(CDINTERMEDIATE, "cd_variable_mapping.csv"))

# create vector of all tax-calculator variables for which we might want summaries
taxcalc_vars <- c("c00100", "e00200", "e00300", "e01700", "e26270", "e18400", "e18500", "iitax")

tmdplusweights <- tmd2021 |> 
  select(RECID, data_source, MARS, us=s006, all_of(taxcalc_vars)) |> 
  mutate(row=row_number(), wtdn=1) |> 
  # put agibin on the file
  mutate(irange=cut(c00100, icuts, right = FALSE, ordered_result = TRUE),
         irange = factor(irange, 
                         levels = levels(irange), # Ensure ordering is maintained
                         labels = str_replace(levels(irange), ",", ", ")), # make more-readable labels
         # add a total to the factor because down the road we will have totals ??
         irange = fct_expand(irange, "total"),
         irange = fct_relevel(irange, "total")) |> 
  left_join(cdweights, by = join_by(row)) |> 
  relocate(row, wtdn, irange, .after = RECID) |> 
  relocate(us, .before = ak00)
  
glimpse(tmdplusweights)
tmdplusweights[1:5, c(1:13, ncol(tmdplusweights))]

```

## Calculate sums and save

Calculate sums by area, data_source, and AGI range. The 

Making this step efficient is crucial. If we have 10 variables of interest 400+ area weights, 9 AGI categories, and 2 data_source categories, giving a large number of potential sums.

The approach taken here is to make a longer tmd file that has one row for each tax-calculator variable of interest for each tax unit, while maintaining the 400+ columns for areas, multiplying each variable's value by all of the weights (400+ weighted values) and summing by groups of interest. This is the second-fastest of the approaches investigated, and the easiest and least-error-prone to maintain as we add variables of interest.

The resulting dataframe with sums of interest is small, and easy to manipulate.


```{r}
#| label: calcsums
#| output: false

a <- proc.time()
long1 <- tmdplusweights |> 
  pivot_longer(cols = c(wtdn, all_of(taxcalc_vars)),
               names_to = "variable")

wtdsums <- long1 |> 
  summarise(across(us:wy00,
                \(x) sum(x * value)),
            .by=c(MARS, irange, data_source, variable)) |> 
  pivot_longer(-c(MARS, irange, data_source, variable),
               names_to = "statecd",
               values_to = "sum")

rm(long1)
b <- proc.time()
b - a # about 10 secs

# do some checking
count(wtdsums, MARS)
count(wtdsums, irange)
count(wtdsums, variable)
count(wtdsums,  data_source)
count(wtdsums, data_source, MARS)

wtdsums$statecd |> unique() |> length()
wtdsums$statecd |> unique() # 436 + us

# wtdsums
write_csv(wtdsums, here::here("intermediate", "wtdsums.csv"))

```

## Extend weighted sums to include other subgroup sums

We just created weighted sums of tmd data by the following combination:

-   Selected tmd variables, by
-   Congressional district, by
-   data_source, by
-   Marital status, by
-   AGI range

Now we want to create additional derivative summaries and add them to our summary data:

-   total across all marital statuses, and then add it to existing totals

-   then total across all agi ranges, within the other categories, and add it to new existing totals

This should be enough, but we could want additional subtotal categories

Create and save an enhanced weighted sums file from this.

```{r}

# sums across all marital status
sums_plus_marstot <- wtdsums |> 
  summarise(sum=sum(sum), 
            .by=c(statecd, irange, data_source, variable)) |> 
  mutate(MARS=0) |> 
  bind_rows(wtdsums)

# quick checks
count(sums_plus_marstot, MARS)
count(sums_plus_marstot, irange)
skim(sums_plus_marstot)
  
# sum across all income ranges
sums_plus_irangetot <- sums_plus_marstot |> 
  summarise(sum=sum(sum), 
            .by=c(statecd, MARS, data_source, variable)) |> 
  mutate(irange="total",
         irange = factor(irange, levels = levels(wtdsums$irange), ordered = TRUE)) |> 
  bind_rows(sums_plus_marstot)

# quick checks
count(sums_plus_irangetot, MARS)
count(sums_plus_irangetot, irange)
count(sums_plus_irangetot, variable)
count(sums_plus_irangetot, MARS, variable)
skim(sums_plus_irangetot)

write_csv(sums_plus_irangetot, here::here("intermediate", "wtdsums_enhanced.csv"))

```


```{r}
#| label: wide-approach
#| eval: false
#| output: false


# wide approach - harder to maintain because a new sum calculation must be created for each variable added
# a <- proc.time()
# sums1 <- tmdplusweights |>
#   summarise(across(c(us, ak00:wy00),
#                    list(wtdn = \(x) sum(x * wtdn),
#                         c00100 = \(x) sum(x * c00100),
#                         e00200 = \(x) sum(x * e00200),
#                         e00300 = \(x) sum(x * e00300),
#                         e26270 = \(x) sum(x * e26270),
#                         iitax = \(x) sum(x * iitax))),
#             .by=c(MARS, irange, data_source)) |>
#   pivot_longer(-c(MARS, irange, data_source), values_to = "sum") |>
#   separate(name, into=c("statecd", "variable"))
# b <- proc.time()
# b - a # about 2.4 secs
# sums1

# check that the two approaches produce the same result
# count(sums1, data_source); count(sums2, data_source)
# count(sums1, variable); count(sums2, variable)
# 
# bind_rows(sums1 |> mutate(src="sums1"),
#                    sums2 |> mutate(src="sums2")) |> 
#   pivot_wider(names_from = src, values_from = sum) |> 
#   mutate(diff=sums2 - sums1) |> 
#   arrange(desc(abs(diff)))
```



