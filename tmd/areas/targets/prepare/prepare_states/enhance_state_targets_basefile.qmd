---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Enhance state targets basefile

The targets basefile created in a prior .qmd file has a population target for each state and many SOI-based targets. However, for some target concepts SOI data are either not available or are inappropriate. 

For example, for SALT deductions, for variables ending in 18400 (state and local income or sales tax deduction) or 18500 (real estate taxes paid) the SOI data for 2021 represent the amount available to be deducted by 2021 itemizers (at 2021 levels, under 2021), before the SALT cap. Because the TCJA raised the standard deduction sharply, there are far fewer itemizers in 2021 than pre-TCJA. We want our targets to be for available deductions including nonitemizers, in a manner consistent with the way the data are measured in our TMD variables e18400 and e18500.

We construct alternative SALT targets below.


```{r}
#| label: setup
#| output: false

suppressPackageStartupMessages(source(here::here("R", "libraries.R")))
source(here::here("R", "constants.R"))
source(here::here("R", "functions.R"))

```


Define which SOI variables will be used to share which tmd variables.

```{r}
#| label: construct-mappings
#| output: false

mappings <- read_csv(
"tmdvar, basesoivname
e18400, 18400
e18500, 18500
", col_types="cc")

mappings

```



## Get data

```{r}
#| label: get-data
#| output: false

agilabels <- read_csv(fs::path(DINTERMEDIATE, "agilabels.csv"))
agilabels
STAGICUTS <- c(agilabels$agilo, agilabels$agihi) |> unique() |> sort()
# agistub=cut(c00100, STAGICUTS, right = FALSE, ordered_result = TRUE) |> as.integer()

fpath <-  fs::path(TMDDATA, "cached_allvars.csv")
tmd2021 <- vroom(fpath)
ns(tmd2021)

tmd2021 <- tmd2021 |> 
  mutate(agistublab=cut(c00100, STAGICUTS, right = FALSE, ordered_result = TRUE),
         agistub=agistublab |> as.integer()) |> 
  left_join(agilabels, by = join_by(agistub))
# has more agistub info than we need but makes it easy to be sure we have the right stubs
count(tmd2021, agistub, agistublab, agilo, agihi, agilabel)

basetargets <- read_csv(fs::path(DINTERMEDIATE, "basetargets.csv"))
glimpse(basetargets)

```

## Variables shared to states

```{r}
#| label: get-tmdsums

tmdsums1 <- tmd2021 |> 
  filter(data_source==1) |> 
  select(s006, agistub, agilabel, all_of(mappings$tmdvar)) |> 
  pivot_longer(-c(s006, agistub, agilabel),
               names_to = "tmdvar") |> 
  summarize(nzcount=sum(s006 * (value !=0)),
            amount=sum(s006 * value),
            .by=c(tmdvar, agistub, agilabel)) |> 
  arrange(tmdvar, agistub)

tmdallincomes <- tmdsums1 |> 
  summarise(nzcount=sum(nzcount),
            amount=sum(amount),
            .by=c(tmdvar)) |> 
  mutate(agistub=0, agilabel="Total")

tmdsums <- bind_rows(tmdsums1,
                     tmdallincomes) |> 
  arrange(tmdvar, agistub) |> 
  pivot_longer(-c(tmdvar, agistub, agilabel),
               names_to = "vtype",
               values_to = "tmdsum") |>
  mutate(fstatus=0, scope=1, 
         count=case_when(vtype=="nzcount" ~ 2,
                         vtype=="amount" ~ 0,
                         .default = -9e99)) |> 
  left_join(mappings, 
            by = join_by(tmdvar)) |> 
  arrange(tmdvar, scope, count, fstatus)
tmdsums

```


```{r}
#| label: get-variable-shares

# note: by using the us record we include the (trivial) OA amounts, which 
#   seems right - implicitly they are in the tmd data
soivname_shares <- basetargets |> 
  filter(basesoivname %in% mappings$basesoivname) |> 
  mutate(soi_ussum=target[stabbr=="US"],
         soi_share=ifelse(soi_ussum==0, 0, target / soi_ussum),
            .by=c(basesoivname, count, scope, fstatus, agistub))

check <- soivname_shares |> filter(stabbr=="US")
check <- soivname_shares |> filter(stabbr=="NY")

soivname_targets <- soivname_shares |> 
  left_join(tmdsums |> 
              select(tmdvar, basesoivname, agistub, scope, fstatus, count, tmdsum),
              by = join_by(basesoivname, scope, fstatus, count, agistub)) |> 
  mutate(target=tmdsum * soi_share,
         basesoivname=paste0("tmd", str_sub(tmdvar, 2, -1), "_shared_by_soi", basesoivname),
         soivname=paste0(str_sub(soivname, 1, 1), basesoivname))

check <- soivname_targets |> filter(stabbr=="NY")

count(soivname_targets, tmdvar, basesoivname, soivname)

write_csv(soivname_targets, fs::path(DINTERMEDIATE, "additional_targets.csv"))

```

## Stack basefile targets and additional targets

```{r}
#| label: stack-targets

basetargets <- read_csv(fs::path(DINTERMEDIATE, "basetargets.csv"))
additional_targets <- read_csv(fs::path(DINTERMEDIATE, "additional_targets.csv"))
ns(additional_targets)

setdiff(names(basetargets), names(additional_targets)) # none missing
setdiff(names(additional_targets), names(basetargets)) # see below
# "soi_ussum" "soi_share" "tmdvar" "tmdsum"
# we can drop all of these

# re-examine additional targets
glimpse(additional_targets)
count(additional_targets, basesoivname, soivname, description)
count(additional_targets, tmdvar, basetmdvname, basesoivname, soivname, description)

stack <- bind_rows(basetargets, 
                   additional_targets |> 
                     select(all_of(names(basetargets)))) |> 
  # sort is 1 for the  population record, NA for others - so pop sorts first
  # set desired order
  arrange(stabbr, sort, scope, fstatus, basesoivname, count, agistub) |> 
  # now calc sort
  mutate(sort=row_number(), .by=stabbr) |> 
  select(stabbr, sort, count, scope, agilo, agihi, fstatus, target, basesoivname, soivname, description, agistub, agilabel)

# varname,count,scope,agilo,agihi,fstatus,target
check <- stack |> filter(stabbr=="NY")
check2 <- count(check, basesoivname, soivname, description)

write_csv(stack, fs::path(DINTERMEDIATE, "enhanced_targets.csv"))

```



## Additional notes

```{r}
#| label: notes
#| output: false

# documentation for the targets.csv data file

# sample file excerpt
# varname,count,scope,agilo,agihi,fstatus,target
# XTOT,       0,    0,-9e99, 9e99,      0,  33e6
# e00300,     0,    1,-9e99, 9e99,      0,  20e9
# e00900,     0,    1,-9e99, 9e99,      0,  30e9
# e00200,     0,    1,-9e99, 9e99,      0,1000e9
# e02000,     0,    1,-9e99, 9e99,      0,  30e9
# e02400,     0,    1,-9e99, 9e99,      0,  60e9

# varname: any Tax-Calculator input variable name plus any Tax-Calculator calculated variable in the list of cached variables in the tmd/storage/__init__.py file
# count: integer in [0,4] range:
# count==0 implies dollar total of varname is tabulated
# count==1 implies number of tax units with any value of varname is tabulated
# count==2 implies number of tax units with a nonzero value of varname is tabulated
# count==3 implies number of tax units with a positive value of varname is tabulated
# count==4 implies number of tax units with a negative value of varname is tabulated

# scope: integer in [0,2] range:
# scope==0 implies all tax units are tabulated
# scope==1 implies only PUF-derived filing units are tabulated
# scope==2 implies only CPS-derived filing units are tabulated

# agilo: float representing lower bound of the AGI range (which is included in the range) that is tabulated.
# agihi: float representing upper bound of the AGI range (which is excluded from the range) that is tabulated.

# fstatus: integer in [0,5] range:
# fstatus=0 implies all filing statuses are tabulated
# other fstatus values imply just the tax units with the Tax-Calculator MARS variable equal to fstatus are included in the tabulation

# target: target amount:
# dollars if count==0
# number of tax units if count>0

```
