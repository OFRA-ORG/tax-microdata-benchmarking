---
output: html_document
editor_options: 
 chunk_output_type: console
---

# Clean up SOI documentation files

## Setup

```{r}
#| label: setup

source(here::here("R", "libraries.R"))
source(here::here("R", "constants.R"))
source(here::here("R", "functions.R"))

library(stringdist) # for calculating "distances" between strings

```

## Read, stack, and save the documentation data

### Read and stack documentation files for different years

Start with *soi_states_variable_documentation.xlsx*, a hand-created workbook that has a sheet for each year from 2015-2021. Each sheet has a table from the SOI documentation file for that year, with variable names, variable descriptions, and certain other information. For example, the SOI file for 2021 is named *21incmdocguide.doc*. 

See the notes sheet in the workbook for how the Word tables were copied to Excel. The basic idea was to copy each table to a sheet and make the absolute minimum manual changes needed to make the table rectangular and computer-readable. The goal is to do as much parsing and cleaning in computer code as possible to reduce risk of errors and make it reproducible.


```{r}
#| label: stack-documentation
#| output: false

fname <- "soi_states_variable_documentation.xlsx"
fpath <- fs::path(DRAW, fname)

f <- function(year){
  df1 <- readxl::read_xlsx(fpath, sheet = as.character(year), col_types = "text")
  df2 <- df1 |> 
    select(vname=1, description=2, reference=3, type=4) |> 
    filter(if_any(everything(), ~!is.na(.))) |> 
    # after verifying that AGI_STUB is the only variable with NA in vname
    # fill down and then concatenate the reference column
    fill(vname, description, type, .direction="down") |> 
    mutate(reference = paste(reference, collapse = "\n"), .by=vname) |> 
    distinct() |> 
    # for now, make mistaken references NA
    mutate(reference=ifelse(!is.na(as.numeric(reference)), NA_character_, reference),
           reference=ifelse(reference=="NA", NA_character_, reference),
           year=!!year) |> 
    relocate(year)
  df2
}

# f(2021)
# f(2020)
# f(2019)
# f(2018)
# f(2017)
# f(2016)
# f(2015)

stacked_docs <- purrr::map(2015:2021, f) |> 
  list_rbind()

count(stacked_docs, year)

# write_csv(df, fs::path(DINTERMEDIATE, "soi_documentation.csv"))

```

```{r}


# identify variables that have more than one description, and then
# identify instances where the descriptions are highly dissimilar


f <- function(strings) {
  if(length(strings)==1) return(rep(0, length(strings)))
  c(NA_integer_, sapply(2:length(strings), \(i) stringdist(strings[i], strings[i - 1], method = "lv")))
}

distances <- df |> 
  select(year, vname, description) |> 
  arrange(vname, year) |>
  mutate(n=n(),
         nunique=length(unique(description)), 
         .by=vname) |> 
  # filter(nunique > 1) |> 
  mutate(distance=f(description), 
         maxdist=max(distance, na.rm=TRUE),
         .by=vname)
count(distances, maxdist)

# analysis
cleanit <- function(strings) str_remove(strings, " \\[\\d+(, \\d+)*\\]")
distances |> filter(maxdist == 2) # nothing to worry about, remove ending and keep last
distances |> filter(maxdist == 3) 
distances |> filter(maxdist == 4) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 5) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 14) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 17) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 18) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 20) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 30) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 31) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 32) |> mutate(d2=cleanit(description))
distances |> filter(maxdist == 37) |> mutate(d2=cleanit(description))

adjusted_descriptions <- read_delim(
"vname; adjusted
A00100; Adjusted gross income (AGI) amount
N06500; Number of returns with income tax after credits (pre-2018 is different)
A06500; Income tax after credits amount (pre-2018 is different)
A07180; Nonrefundable child care credit amount (pre-2021 is different)
N07180; Number of returns with nonrefundable child care credit (pre-2021 is different)
N19700; Number of returns with Total charitable contributions (pre-2017 is different)
A19700; Total charitable contributions amount (pre-2017 is different)
A07225; Nonrefundable child and other dependent tax credit amount (pre-2021 is different)
N07225; Number of returns with nonrefundable child and other dependent tax credit (pre-2021 is different)
A20950; Other non-limited miscellaneous deductions amount (pre-2018 is different)
N11070; Number of returns with refundable child tax credit or additional child tax credit (pre-2021 is different)
A11070; Refundable child tax credit or additional child tax credit amount (pre-2021 is different)
A11450; Qualified sick and family leave credit for leave taken before April 1, 2021 amount (pre-2021 is different)
N11450; Number of returns with qualified sick and family leave credit for leave taken before April 1, 2021 (pre-2021 is different)
", delim=";", trim_ws=TRUE)
adjusted_descriptions

adjusted1 <- distances |> 
  mutate(cleaned=cleanit(description),
         last=last(cleaned),
         .by=vname) |> 
  left_join(adjusted_descriptions,
            by = join_by(vname)) |> 
  mutate(udescription=ifelse(!is.na(adjusted),
                             adjusted,
                             last))

adjusted2 <- adjusted1 |> 
  select(year, vname, description, udescription)


# strings <- c("Economic impact payment first round amount [16, 17]", "abc [3]")
# str_remove(strings, " \\[\\d+(, \\d+)*\\]")
# cleaned_strings <- str_remove(strings, " \\[\\d+\\]")

# install.packages("stringdist")


# Sample vector of strings
# strings <- c("apple", "apples", "apples", "apricot", "banana", "bandana", "band")
# #                         1         0         5         7         1         3
# f(strings)
# # Compute the similarity between consecutive elements
# distances <- sapply(2:length(strings), function(i) stringdist(strings[i], strings[i - 1], method = "lv"))
# sapply(2:length(strings), \(i) stringdist(strings[i], strings[i - 1], method = "lv"))
# distances


```

